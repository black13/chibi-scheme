/* Automatically generated by chibi-ffi; version: 0.4 */

#include <chibi/eval.h>

#include <sys/types.h>

#include <fcntl.h>
/* Win32 shim for (chibi filesystem) */

#include <windows.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <direct.h>

static int mkdir_shim(const char* path, int ignored) {
    return mkdir(path);
}

#if !defined(__MINGW32__) && !defined(__MINGW64__)
/* Flags for _access() API */
#define R_OK 4
#define W_OK 2
#define X_OK 1 /* Follow MinGW */

#define SHIM_WIN32_STAT_IS(m, flg) ((m & _S_IFMT) == flg)
#define S_ISREG(m) SHIM_WIN32_STAT_IS(m, _S_IFREG)
#define S_ISDIR(m) SHIM_WIN32_STAT_IS(m, _S_IFDIR)
#define S_ISCHR(m) SHIM_WIN32_STAT_IS(m, _S_IFCHR)
#define S_ISFIFO(m) SHIM_WIN32_STAT_IS(m, _S_IFIFO)
#define S_ISBLK(m) 0
#endif

#define S_ISLNK(m) 0
#define S_ISSOCK(m) S_ISFIFO(m)

struct dirent {
    char d_name[MAX_PATH];
};

struct DIR_s {
    int want_next;
    HANDLE hFind;
    struct dirent result;
};

typedef struct DIR_s DIR;

static DIR* opendir(const char* path) {
    HANDLE hFind;
    WIN32_FIND_DATAA ffd;
    DIR* dp;
    char* query;
    query = malloc(MAX_PATH + 1);
    if(!query){
        errno = ENOMEM;
        return NULL;
    }
    query[0] = 0;
    strncat(query, path, MAX_PATH);
    strncat(query, "\\*", MAX_PATH);
    query[MAX_PATH] = 0;
    hFind = FindFirstFileA(query, &ffd);
    if(hFind == INVALID_HANDLE_VALUE){
        switch(GetLastError()){
            case ERROR_FILE_NOT_FOUND:
                errno = ENOENT;
                break;
            default:
                errno = EACCES;
                break;
        }
        return NULL;
    }
    free(query);
    dp = malloc(sizeof(DIR));
    if(!dp){
        errno = ENOMEM;
        return NULL;
    }
    dp->hFind = hFind;
    strncpy(dp->result.d_name, ffd.cFileName, MAX_PATH);
    dp->want_next = 0;
    return dp;
}

static struct dirent *readdir(DIR *dp) {
    BOOL b;
    WIN32_FIND_DATAA ffd;
    if(dp->want_next){
        /* Query the next file */
        b = FindNextFile(dp->hFind, &ffd);
        if(! b){
            return NULL;
        }
        strncpy(dp->result.d_name, ffd.cFileName, MAX_PATH);
    }
    dp->want_next = 1;
    return &dp->result;
}

static int closedir(DIR *dp) {
    BOOL b;
    b = FindClose(dp->hFind);
    if(! b){
        errno = EBADF;
        return -1;
    }
    free(dp);
    return 0;
}
/*
types: (dirent DIR stat)
enums: ()
*/

sexp sexp_is_a_tty_p_stub (sexp ctx, sexp self, sexp_sint_t n, sexp arg0) {
  sexp res;
  if (! (sexp_portp(arg0) || sexp_filenop(arg0) || sexp_fixnump(arg0)))
    return sexp_xtype_exception(ctx, self, "not a port or file descriptor",arg0);
  res = sexp_make_boolean(isatty((sexp_portp(arg0) ? sexp_port_fileno(arg0) : sexp_filenop(arg0) ? sexp_fileno_fd(arg0) : sexp_unbox_fixnum(arg0))));
  return res;
}

sexp sexp_chmod_stub (sexp ctx, sexp self, sexp_sint_t n, sexp arg0, sexp arg1) {
  sexp res;
  if (! sexp_stringp(arg0))
    return sexp_type_exception(ctx, self, SEXP_STRING, arg0);
  if (! sexp_exact_integerp(arg1))
    return sexp_type_exception(ctx, self, SEXP_FIXNUM, arg1);
  res = sexp_make_integer(ctx, chmod(sexp_string_data(arg0), sexp_sint_value(arg1)));
  return res;
}

sexp sexp_file_access_stub (sexp ctx, sexp self, sexp_sint_t n, sexp arg0, sexp arg1) {
  sexp res;
  if (! sexp_stringp(arg0))
    return sexp_type_exception(ctx, self, SEXP_STRING, arg0);
  if (! sexp_exact_integerp(arg1))
    return sexp_type_exception(ctx, self, SEXP_FIXNUM, arg1);
  res = sexp_make_integer(ctx, access(sexp_string_data(arg0), sexp_sint_value(arg1)));
  return res;
}

sexp sexp_open_stub (sexp ctx, sexp self, sexp_sint_t n, sexp arg0, sexp arg1, sexp arg2) {
  sexp res;
  if (! sexp_stringp(arg0))
    return sexp_type_exception(ctx, self, SEXP_STRING, arg0);
  if (! sexp_exact_integerp(arg1))
    return sexp_type_exception(ctx, self, SEXP_FIXNUM, arg1);
  if (! sexp_exact_integerp(arg2))
    return sexp_type_exception(ctx, self, SEXP_FIXNUM, arg2);
  res = sexp_make_fileno(ctx, sexp_make_fixnum(open(sexp_string_data(arg0), sexp_sint_value(arg1), sexp_sint_value(arg2))), SEXP_FALSE);
  return res;
}

sexp sexp_close_file_descriptor_stub (sexp ctx, sexp self, sexp_sint_t n, sexp arg0) {
  int err = 0;
  sexp res;
  if (! (sexp_filenop(arg0) || sexp_fixnump(arg0)))
    return sexp_type_exception(ctx, self, SEXP_FILENO, arg0);
  err = close((sexp_filenop(arg0) ? sexp_fileno_fd(arg0) : sexp_unbox_fixnum(arg0)));
  if (err) {
  res = SEXP_FALSE;
  } else {
  res = SEXP_TRUE;
  }
  return res;
}

sexp sexp_duplicate_file_descriptor_to_stub (sexp ctx, sexp self, sexp_sint_t n, sexp arg0, sexp arg1) {
  int err = 0;
  sexp res;
  if (! (sexp_filenop(arg0) || sexp_fixnump(arg0)))
    return sexp_type_exception(ctx, self, SEXP_FILENO, arg0);
  if (! (sexp_filenop(arg1) || sexp_fixnump(arg1)))
    return sexp_type_exception(ctx, self, SEXP_FILENO, arg1);
  err = dup2((sexp_filenop(arg0) ? sexp_fileno_fd(arg0) : sexp_unbox_fixnum(arg0)), (sexp_filenop(arg1) ? sexp_fileno_fd(arg1) : sexp_unbox_fixnum(arg1)));
  if (err) {
  res = SEXP_FALSE;
  } else {
  res = SEXP_TRUE;
  }
  return res;
}

sexp sexp_duplicate_file_descriptor_stub (sexp ctx, sexp self, sexp_sint_t n, sexp arg0) {
  sexp res;
  if (! (sexp_filenop(arg0) || sexp_fixnump(arg0)))
    return sexp_type_exception(ctx, self, SEXP_FILENO, arg0);
  res = sexp_make_fileno(ctx, sexp_make_fixnum(dup((sexp_filenop(arg0) ? sexp_fileno_fd(arg0) : sexp_unbox_fixnum(arg0)))), SEXP_FALSE);
  return res;
}

sexp sexp_readdir_stub (sexp ctx, sexp self, sexp_sint_t n, sexp arg0) {
  sexp res;
  if (! (sexp_pointerp(arg0) && (sexp_pointer_tag(arg0) == sexp_unbox_fixnum(sexp_opcode_arg1_type(self)))))
    return sexp_type_exception(ctx, self, sexp_unbox_fixnum(sexp_opcode_arg1_type(self)), arg0);
  res = sexp_make_cpointer(ctx, sexp_unbox_fixnum(sexp_opcode_return_type(self)), readdir((DIR*)sexp_cpointer_value(arg0)), arg0, 0);
  return res;
}

sexp sexp_opendir_stub (sexp ctx, sexp self, sexp_sint_t n, sexp arg0) {
  sexp res;
  if (! sexp_stringp(arg0))
    return sexp_type_exception(ctx, self, SEXP_STRING, arg0);
  res = sexp_make_cpointer(ctx, sexp_unbox_fixnum(sexp_opcode_return_type(self)), opendir(sexp_string_data(arg0)), SEXP_FALSE, 1);
  return res;
}

sexp sexp_delete_directory_stub (sexp ctx, sexp self, sexp_sint_t n, sexp arg0) {
  int err = 0;
  sexp res;
  if (! sexp_stringp(arg0))
    return sexp_type_exception(ctx, self, SEXP_STRING, arg0);
  err = rmdir(sexp_string_data(arg0));
  if (err) {
  res = SEXP_FALSE;
  } else {
  res = SEXP_TRUE;
  }
  return res;
}

sexp sexp_create_directory_stub (sexp ctx, sexp self, sexp_sint_t n, sexp arg0, sexp arg1) {
  int err = 0;
  sexp res;
  if (! sexp_stringp(arg0))
    return sexp_type_exception(ctx, self, SEXP_STRING, arg0);
  if (! sexp_exact_integerp(arg1))
    return sexp_type_exception(ctx, self, SEXP_FIXNUM, arg1);
  err = mkdir_shim(sexp_string_data(arg0), sexp_sint_value(arg1));
  if (err) {
  res = SEXP_FALSE;
  } else {
  res = SEXP_TRUE;
  }
  return res;
}

sexp sexp_change_directory_stub (sexp ctx, sexp self, sexp_sint_t n, sexp arg0) {
  int err = 0;
  sexp res;
  if (! sexp_stringp(arg0))
    return sexp_type_exception(ctx, self, SEXP_STRING, arg0);
  err = chdir(sexp_string_data(arg0));
  if (err) {
  res = SEXP_FALSE;
  } else {
  res = SEXP_TRUE;
  }
  return res;
}

sexp sexp_current_directory_stub (sexp ctx, sexp self, sexp_sint_t n) {
  char *err;
  char buf0[256];
  int len0;
  char *tmp0;
  sexp res;
  sexp_gc_var1(res0);
  sexp_gc_preserve1(ctx, res0);
  len0 = 256;
  tmp0 = buf0;
 loop:
  err = getcwd(tmp0, len0);
  if (!err) {
  if (len0 != 256)
    free(tmp0);
  len0 *= 2;
  tmp0 = (char*) calloc(len0, sizeof(tmp0[0]));
  goto loop;
  } else {
  res0 = sexp_c_string(ctx, tmp0, -1);
  res = res0;
  }
  if (len0 != 256)
    free(tmp0);
  sexp_gc_release1(ctx);
  return res;
}

sexp sexp_rename_file_stub (sexp ctx, sexp self, sexp_sint_t n, sexp arg0, sexp arg1) {
  int err = 0;
  sexp res;
  if (! sexp_stringp(arg0))
    return sexp_type_exception(ctx, self, SEXP_STRING, arg0);
  if (! sexp_stringp(arg1))
    return sexp_type_exception(ctx, self, SEXP_STRING, arg1);
  err = rename(sexp_string_data(arg0), sexp_string_data(arg1));
  if (err) {
  res = SEXP_FALSE;
  } else {
  res = SEXP_TRUE;
  }
  return res;
}

sexp sexp_25_delete_file_stub (sexp ctx, sexp self, sexp_sint_t n, sexp arg0) {
  int err = 0;
  sexp res;
  if (! sexp_stringp(arg0))
    return sexp_type_exception(ctx, self, SEXP_STRING, arg0);
  err = unlink(sexp_string_data(arg0));
  if (err) {
  res = SEXP_FALSE;
  } else {
  res = SEXP_TRUE;
  }
  return res;
}

sexp sexp_fstat_stub (sexp ctx, sexp self, sexp_sint_t n, sexp arg0) {
  int err = 0;
  struct stat* tmp1;
  sexp res;
  sexp_gc_var1(res1);
  if (! sexp_exact_integerp(arg0))
    return sexp_type_exception(ctx, self, SEXP_FIXNUM, arg0);
  sexp_gc_preserve1(ctx, res1);
  tmp1 = (struct stat*) calloc(1, 1 + sizeof(tmp1[0]));
  err = fstat(sexp_sint_value(arg0), tmp1);
  if (err) {
  res = SEXP_FALSE;
  } else {
  res1 = sexp_make_cpointer(ctx, sexp_unbox_fixnum(sexp_opcode_arg2_type(self)), tmp1, SEXP_FALSE, 1);
  res = res1;
  }
  sexp_gc_release1(ctx);
  return res;
}

sexp sexp_stat_stub (sexp ctx, sexp self, sexp_sint_t n, sexp arg0) {
  int err = 0;
  struct stat* tmp1;
  sexp res;
  sexp_gc_var1(res1);
  if (! sexp_stringp(arg0))
    return sexp_type_exception(ctx, self, SEXP_STRING, arg0);
  sexp_gc_preserve1(ctx, res1);
  tmp1 = (struct stat*) calloc(1, 1 + sizeof(tmp1[0]));
  err = stat(sexp_string_data(arg0), tmp1);
  if (err) {
  res = SEXP_FALSE;
  } else {
  res1 = sexp_make_cpointer(ctx, sexp_unbox_fixnum(sexp_opcode_arg2_type(self)), tmp1, SEXP_FALSE, 1);
  res = res1;
  }
  sexp_gc_release1(ctx);
  return res;
}

sexp sexp_S_ISSOCK_stub (sexp ctx, sexp self, sexp_sint_t n, sexp arg0) {
  sexp res;
  if (! sexp_exact_integerp(arg0))
    return sexp_type_exception(ctx, self, SEXP_FIXNUM, arg0);
  res = sexp_make_boolean(S_ISSOCK(sexp_uint_value(arg0)));
  return res;
}

sexp sexp_S_ISLNK_stub (sexp ctx, sexp self, sexp_sint_t n, sexp arg0) {
  sexp res;
  if (! sexp_exact_integerp(arg0))
    return sexp_type_exception(ctx, self, SEXP_FIXNUM, arg0);
  res = sexp_make_boolean(S_ISLNK(sexp_uint_value(arg0)));
  return res;
}

sexp sexp_S_ISFIFO_stub (sexp ctx, sexp self, sexp_sint_t n, sexp arg0) {
  sexp res;
  if (! sexp_exact_integerp(arg0))
    return sexp_type_exception(ctx, self, SEXP_FIXNUM, arg0);
  res = sexp_make_boolean(S_ISFIFO(sexp_uint_value(arg0)));
  return res;
}

sexp sexp_S_ISBLK_stub (sexp ctx, sexp self, sexp_sint_t n, sexp arg0) {
  sexp res;
  if (! sexp_exact_integerp(arg0))
    return sexp_type_exception(ctx, self, SEXP_FIXNUM, arg0);
  res = sexp_make_boolean(S_ISBLK(sexp_uint_value(arg0)));
  return res;
}

sexp sexp_S_ISCHR_stub (sexp ctx, sexp self, sexp_sint_t n, sexp arg0) {
  sexp res;
  if (! sexp_exact_integerp(arg0))
    return sexp_type_exception(ctx, self, SEXP_FIXNUM, arg0);
  res = sexp_make_boolean(S_ISCHR(sexp_uint_value(arg0)));
  return res;
}

sexp sexp_S_ISDIR_stub (sexp ctx, sexp self, sexp_sint_t n, sexp arg0) {
  sexp res;
  if (! sexp_exact_integerp(arg0))
    return sexp_type_exception(ctx, self, SEXP_FIXNUM, arg0);
  res = sexp_make_boolean(S_ISDIR(sexp_uint_value(arg0)));
  return res;
}

sexp sexp_S_ISREG_stub (sexp ctx, sexp self, sexp_sint_t n, sexp arg0) {
  sexp res;
  if (! sexp_exact_integerp(arg0))
    return sexp_type_exception(ctx, self, SEXP_FIXNUM, arg0);
  res = sexp_make_boolean(S_ISREG(sexp_uint_value(arg0)));
  return res;
}

sexp sexp_dirent_get_d_name (sexp ctx, sexp self, sexp_sint_t n, sexp x) {
  if (! (sexp_pointerp(x) && (sexp_pointer_tag(x) == sexp_unbox_fixnum(sexp_opcode_arg1_type(self)))))
    return sexp_type_exception(ctx, self, sexp_unbox_fixnum(sexp_opcode_arg1_type(self)), x);
  return sexp_c_string(ctx, ((struct dirent*)sexp_cpointer_value(x))->d_name, -1);
}

sexp sexp_closedir_stub (sexp ctx, sexp self, sexp_sint_t n, sexp x) {
  if (sexp_cpointer_freep(x)) {
    closedir(
#ifdef __cplusplus
(DIR*)
#endif
sexp_cpointer_value(x));
    sexp_cpointer_freep(x) = 0;
  }
  return SEXP_VOID;
}

sexp sexp_stat_get_st_dev (sexp ctx, sexp self, sexp_sint_t n, sexp x) {
  if (! (sexp_pointerp(x) && (sexp_pointer_tag(x) == sexp_unbox_fixnum(sexp_opcode_arg1_type(self)))))
    return sexp_type_exception(ctx, self, sexp_unbox_fixnum(sexp_opcode_arg1_type(self)), x);
  return sexp_make_unsigned_integer(ctx, ((struct stat*)sexp_cpointer_value(x))->st_dev);
}

sexp sexp_stat_get_st_ino (sexp ctx, sexp self, sexp_sint_t n, sexp x) {
  if (! (sexp_pointerp(x) && (sexp_pointer_tag(x) == sexp_unbox_fixnum(sexp_opcode_arg1_type(self)))))
    return sexp_type_exception(ctx, self, sexp_unbox_fixnum(sexp_opcode_arg1_type(self)), x);
  return sexp_make_unsigned_integer(ctx, ((struct stat*)sexp_cpointer_value(x))->st_ino);
}

sexp sexp_stat_get_st_mode (sexp ctx, sexp self, sexp_sint_t n, sexp x) {
  if (! (sexp_pointerp(x) && (sexp_pointer_tag(x) == sexp_unbox_fixnum(sexp_opcode_arg1_type(self)))))
    return sexp_type_exception(ctx, self, sexp_unbox_fixnum(sexp_opcode_arg1_type(self)), x);
  return sexp_make_unsigned_integer(ctx, ((struct stat*)sexp_cpointer_value(x))->st_mode);
}

sexp sexp_stat_get_st_nlink (sexp ctx, sexp self, sexp_sint_t n, sexp x) {
  if (! (sexp_pointerp(x) && (sexp_pointer_tag(x) == sexp_unbox_fixnum(sexp_opcode_arg1_type(self)))))
    return sexp_type_exception(ctx, self, sexp_unbox_fixnum(sexp_opcode_arg1_type(self)), x);
  return sexp_make_unsigned_integer(ctx, ((struct stat*)sexp_cpointer_value(x))->st_nlink);
}

sexp sexp_stat_get_st_uid (sexp ctx, sexp self, sexp_sint_t n, sexp x) {
  if (! (sexp_pointerp(x) && (sexp_pointer_tag(x) == sexp_unbox_fixnum(sexp_opcode_arg1_type(self)))))
    return sexp_type_exception(ctx, self, sexp_unbox_fixnum(sexp_opcode_arg1_type(self)), x);
  return sexp_make_unsigned_integer(ctx, ((struct stat*)sexp_cpointer_value(x))->st_uid);
}

sexp sexp_stat_get_st_gid (sexp ctx, sexp self, sexp_sint_t n, sexp x) {
  if (! (sexp_pointerp(x) && (sexp_pointer_tag(x) == sexp_unbox_fixnum(sexp_opcode_arg1_type(self)))))
    return sexp_type_exception(ctx, self, sexp_unbox_fixnum(sexp_opcode_arg1_type(self)), x);
  return sexp_make_unsigned_integer(ctx, ((struct stat*)sexp_cpointer_value(x))->st_gid);
}

sexp sexp_stat_get_st_rdev (sexp ctx, sexp self, sexp_sint_t n, sexp x) {
  if (! (sexp_pointerp(x) && (sexp_pointer_tag(x) == sexp_unbox_fixnum(sexp_opcode_arg1_type(self)))))
    return sexp_type_exception(ctx, self, sexp_unbox_fixnum(sexp_opcode_arg1_type(self)), x);
  return sexp_make_unsigned_integer(ctx, ((struct stat*)sexp_cpointer_value(x))->st_rdev);
}

sexp sexp_stat_get_st_size (sexp ctx, sexp self, sexp_sint_t n, sexp x) {
  if (! (sexp_pointerp(x) && (sexp_pointer_tag(x) == sexp_unbox_fixnum(sexp_opcode_arg1_type(self)))))
    return sexp_type_exception(ctx, self, sexp_unbox_fixnum(sexp_opcode_arg1_type(self)), x);
  return sexp_make_unsigned_integer(ctx, ((struct stat*)sexp_cpointer_value(x))->st_size);
}

sexp sexp_stat_get_st_atime (sexp ctx, sexp self, sexp_sint_t n, sexp x) {
  if (! (sexp_pointerp(x) && (sexp_pointer_tag(x) == sexp_unbox_fixnum(sexp_opcode_arg1_type(self)))))
    return sexp_type_exception(ctx, self, sexp_unbox_fixnum(sexp_opcode_arg1_type(self)), x);
  return sexp_make_integer(ctx, sexp_shift_epoch(((struct stat*)sexp_cpointer_value(x))->st_atime));
}

sexp sexp_stat_get_st_mtime (sexp ctx, sexp self, sexp_sint_t n, sexp x) {
  if (! (sexp_pointerp(x) && (sexp_pointer_tag(x) == sexp_unbox_fixnum(sexp_opcode_arg1_type(self)))))
    return sexp_type_exception(ctx, self, sexp_unbox_fixnum(sexp_opcode_arg1_type(self)), x);
  return sexp_make_integer(ctx, sexp_shift_epoch(((struct stat*)sexp_cpointer_value(x))->st_mtime));
}

sexp sexp_stat_get_st_ctime (sexp ctx, sexp self, sexp_sint_t n, sexp x) {
  if (! (sexp_pointerp(x) && (sexp_pointer_tag(x) == sexp_unbox_fixnum(sexp_opcode_arg1_type(self)))))
    return sexp_type_exception(ctx, self, sexp_unbox_fixnum(sexp_opcode_arg1_type(self)), x);
  return sexp_make_integer(ctx, sexp_shift_epoch(((struct stat*)sexp_cpointer_value(x))->st_ctime));
}


sexp sexp_init_library (sexp ctx, sexp self, sexp_sint_t n, sexp env, const char* version, const sexp_abi_identifier_t abi) {
  sexp sexp_dirent_type_obj;
  sexp sexp_DIR_type_obj;
  sexp sexp_stat_type_obj;
  sexp_gc_var3(name, tmp, op);
  if (!(sexp_version_compatible(ctx, version, sexp_version)
        && sexp_abi_compatible(ctx, abi, SEXP_ABI_IDENTIFIER)))
    return SEXP_ABI_ERROR;
  sexp_gc_preserve3(ctx, name, tmp, op);
  name = sexp_intern(ctx, "access/execute", 14);
  sexp_env_define(ctx, env, name, tmp=sexp_make_integer(ctx, X_OK));
  name = sexp_intern(ctx, "access/write", 12);
  sexp_env_define(ctx, env, name, tmp=sexp_make_integer(ctx, W_OK));
  name = sexp_intern(ctx, "access/read", 11);
  sexp_env_define(ctx, env, name, tmp=sexp_make_integer(ctx, R_OK));
  name = sexp_intern(ctx, "open/append", 11);
  sexp_env_define(ctx, env, name, tmp=sexp_make_integer(ctx, O_APPEND));
  name = sexp_intern(ctx, "open/truncate", 13);
  sexp_env_define(ctx, env, name, tmp=sexp_make_integer(ctx, O_TRUNC));
  name = sexp_intern(ctx, "open/exclusive", 14);
  sexp_env_define(ctx, env, name, tmp=sexp_make_integer(ctx, O_EXCL));
  name = sexp_intern(ctx, "open/create", 11);
  sexp_env_define(ctx, env, name, tmp=sexp_make_integer(ctx, O_CREAT));
  name = sexp_intern(ctx, "open/read-write", 15);
  sexp_env_define(ctx, env, name, tmp=sexp_make_integer(ctx, O_RDWR));
  name = sexp_intern(ctx, "open/write", 10);
  sexp_env_define(ctx, env, name, tmp=sexp_make_integer(ctx, O_WRONLY));
  name = sexp_intern(ctx, "open/read", 9);
  sexp_env_define(ctx, env, name, tmp=sexp_make_integer(ctx, O_RDONLY));
  name = sexp_c_string(ctx, "dirent", -1);
  sexp_dirent_type_obj = sexp_register_c_type(ctx, name, sexp_finalize_c_type);
  tmp = sexp_string_to_symbol(ctx, name);
  sexp_env_define(ctx, env, tmp, sexp_dirent_type_obj);
  sexp_type_slots(sexp_dirent_type_obj) = SEXP_NULL;
  sexp_push(ctx, sexp_type_slots(sexp_dirent_type_obj), sexp_intern(ctx, "d_name", -1));
  sexp_type_getters(sexp_dirent_type_obj) = sexp_make_vector(ctx, SEXP_ONE, SEXP_FALSE);
  sexp_type_setters(sexp_dirent_type_obj) = sexp_make_vector(ctx, SEXP_ONE, SEXP_FALSE);
  name = sexp_c_string(ctx, "DIR", -1);
  sexp_DIR_type_obj = sexp_register_c_type(ctx, name, sexp_closedir_stub);
  tmp = sexp_string_to_symbol(ctx, name);
  sexp_env_define(ctx, env, tmp, sexp_DIR_type_obj);
  name = sexp_c_string(ctx, "stat", -1);
  sexp_stat_type_obj = sexp_register_c_type(ctx, name, sexp_finalize_c_type);
  tmp = sexp_string_to_symbol(ctx, name);
  sexp_env_define(ctx, env, tmp, sexp_stat_type_obj);
  sexp_type_slots(sexp_stat_type_obj) = SEXP_NULL;
  sexp_push(ctx, sexp_type_slots(sexp_stat_type_obj), sexp_intern(ctx, "st_ctime", -1));
  sexp_push(ctx, sexp_type_slots(sexp_stat_type_obj), sexp_intern(ctx, "st_mtime", -1));
  sexp_push(ctx, sexp_type_slots(sexp_stat_type_obj), sexp_intern(ctx, "st_atime", -1));
  sexp_push(ctx, sexp_type_slots(sexp_stat_type_obj), sexp_intern(ctx, "st_size", -1));
  sexp_push(ctx, sexp_type_slots(sexp_stat_type_obj), sexp_intern(ctx, "st_rdev", -1));
  sexp_push(ctx, sexp_type_slots(sexp_stat_type_obj), sexp_intern(ctx, "st_gid", -1));
  sexp_push(ctx, sexp_type_slots(sexp_stat_type_obj), sexp_intern(ctx, "st_uid", -1));
  sexp_push(ctx, sexp_type_slots(sexp_stat_type_obj), sexp_intern(ctx, "st_nlink", -1));
  sexp_push(ctx, sexp_type_slots(sexp_stat_type_obj), sexp_intern(ctx, "st_mode", -1));
  sexp_push(ctx, sexp_type_slots(sexp_stat_type_obj), sexp_intern(ctx, "st_ino", -1));
  sexp_push(ctx, sexp_type_slots(sexp_stat_type_obj), sexp_intern(ctx, "st_dev", -1));
  sexp_type_getters(sexp_stat_type_obj) = sexp_make_vector(ctx, sexp_make_fixnum(11), SEXP_FALSE);
  sexp_type_setters(sexp_stat_type_obj) = sexp_make_vector(ctx, sexp_make_fixnum(11), SEXP_FALSE);
  tmp = sexp_make_type_predicate(ctx, name, sexp_stat_type_obj);
  name = sexp_intern(ctx, "stat?", 5);
  sexp_env_define(ctx, env, name, tmp);
  op = sexp_define_foreign(ctx, env, "stat-ctime", 1, sexp_stat_get_st_ctime);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(sexp_type_tag(sexp_stat_type_obj));
  }
  if (sexp_vectorp(sexp_type_getters(sexp_stat_type_obj))) sexp_vector_set(sexp_type_getters(sexp_stat_type_obj), SEXP_TEN, op);
  op = sexp_define_foreign(ctx, env, "stat-mtime", 1, sexp_stat_get_st_mtime);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(sexp_type_tag(sexp_stat_type_obj));
  }
  if (sexp_vectorp(sexp_type_getters(sexp_stat_type_obj))) sexp_vector_set(sexp_type_getters(sexp_stat_type_obj), SEXP_NINE, op);
  op = sexp_define_foreign(ctx, env, "stat-atime", 1, sexp_stat_get_st_atime);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(sexp_type_tag(sexp_stat_type_obj));
  }
  if (sexp_vectorp(sexp_type_getters(sexp_stat_type_obj))) sexp_vector_set(sexp_type_getters(sexp_stat_type_obj), SEXP_EIGHT, op);
  op = sexp_define_foreign(ctx, env, "stat-size", 1, sexp_stat_get_st_size);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(sexp_type_tag(sexp_stat_type_obj));
  }
  if (sexp_vectorp(sexp_type_getters(sexp_stat_type_obj))) sexp_vector_set(sexp_type_getters(sexp_stat_type_obj), SEXP_SEVEN, op);
  op = sexp_define_foreign(ctx, env, "stat-rdev", 1, sexp_stat_get_st_rdev);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(sexp_type_tag(sexp_stat_type_obj));
  }
  if (sexp_vectorp(sexp_type_getters(sexp_stat_type_obj))) sexp_vector_set(sexp_type_getters(sexp_stat_type_obj), SEXP_SIX, op);
  op = sexp_define_foreign(ctx, env, "stat-gid", 1, sexp_stat_get_st_gid);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(sexp_type_tag(sexp_stat_type_obj));
  }
  if (sexp_vectorp(sexp_type_getters(sexp_stat_type_obj))) sexp_vector_set(sexp_type_getters(sexp_stat_type_obj), SEXP_FIVE, op);
  op = sexp_define_foreign(ctx, env, "stat-uid", 1, sexp_stat_get_st_uid);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(sexp_type_tag(sexp_stat_type_obj));
  }
  if (sexp_vectorp(sexp_type_getters(sexp_stat_type_obj))) sexp_vector_set(sexp_type_getters(sexp_stat_type_obj), SEXP_FOUR, op);
  op = sexp_define_foreign(ctx, env, "stat-nlinks", 1, sexp_stat_get_st_nlink);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(sexp_type_tag(sexp_stat_type_obj));
  }
  if (sexp_vectorp(sexp_type_getters(sexp_stat_type_obj))) sexp_vector_set(sexp_type_getters(sexp_stat_type_obj), SEXP_THREE, op);
  op = sexp_define_foreign(ctx, env, "stat-mode", 1, sexp_stat_get_st_mode);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(sexp_type_tag(sexp_stat_type_obj));
  }
  if (sexp_vectorp(sexp_type_getters(sexp_stat_type_obj))) sexp_vector_set(sexp_type_getters(sexp_stat_type_obj), SEXP_TWO, op);
  op = sexp_define_foreign(ctx, env, "stat-ino", 1, sexp_stat_get_st_ino);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(sexp_type_tag(sexp_stat_type_obj));
  }
  if (sexp_vectorp(sexp_type_getters(sexp_stat_type_obj))) sexp_vector_set(sexp_type_getters(sexp_stat_type_obj), SEXP_ONE, op);
  op = sexp_define_foreign(ctx, env, "stat-dev", 1, sexp_stat_get_st_dev);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(sexp_type_tag(sexp_stat_type_obj));
  }
  if (sexp_vectorp(sexp_type_getters(sexp_stat_type_obj))) sexp_vector_set(sexp_type_getters(sexp_stat_type_obj), SEXP_ZERO, op);
  op = sexp_define_foreign(ctx, env, "closedir", 1, sexp_closedir_stub);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = SEXP_VOID;
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(sexp_type_tag(sexp_DIR_type_obj));
  }
  op = sexp_define_foreign(ctx, env, "dirent-name", 1, sexp_dirent_get_d_name);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_STRING);
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(sexp_type_tag(sexp_dirent_type_obj));
  }
  if (sexp_vectorp(sexp_type_getters(sexp_dirent_type_obj))) sexp_vector_set(sexp_type_getters(sexp_dirent_type_obj), SEXP_ZERO, op);
  op = sexp_define_foreign(ctx, env, "is-a-tty?", 1, sexp_is_a_tty_p_stub);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_BOOLEAN);
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(SEXP_OBJECT);
  }
  op = sexp_define_foreign(ctx, env, "chmod", 2, sexp_chmod_stub);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(SEXP_STRING);
    sexp_opcode_arg2_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
  }
  op = sexp_define_foreign(ctx, env, "file-access", 2, sexp_file_access_stub);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(SEXP_STRING);
    sexp_opcode_arg2_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
  }
  op = sexp_define_foreign_opt(ctx, env, "open", 3, sexp_open_stub, sexp_make_integer(ctx, 420));
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_FILENO);
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(SEXP_STRING);
    sexp_opcode_arg2_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
    sexp_opcode_arg3_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
  }
  op = sexp_define_foreign(ctx, env, "close-file-descriptor", 1, sexp_close_file_descriptor_stub);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_OBJECT);
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(SEXP_FILENO);
  }
  op = sexp_define_foreign(ctx, env, "duplicate-file-descriptor-to", 2, sexp_duplicate_file_descriptor_to_stub);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_OBJECT);
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(SEXP_FILENO);
    sexp_opcode_arg2_type(op) = sexp_make_fixnum(SEXP_FILENO);
  }
  op = sexp_define_foreign(ctx, env, "duplicate-file-descriptor", 1, sexp_duplicate_file_descriptor_stub);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_FILENO);
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(SEXP_FILENO);
  }
  op = sexp_define_foreign(ctx, env, "readdir", 1, sexp_readdir_stub);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(sexp_type_tag(sexp_dirent_type_obj));
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(sexp_type_tag(sexp_DIR_type_obj));
  }
  op = sexp_define_foreign(ctx, env, "opendir", 1, sexp_opendir_stub);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(sexp_type_tag(sexp_DIR_type_obj));
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(SEXP_STRING);
  }
  op = sexp_define_foreign(ctx, env, "delete-directory", 1, sexp_delete_directory_stub);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_OBJECT);
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(SEXP_STRING);
  }
  op = sexp_define_foreign_opt(ctx, env, "create-directory", 2, sexp_create_directory_stub, sexp_make_integer(ctx, 509));
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_OBJECT);
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(SEXP_STRING);
    sexp_opcode_arg2_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
  }
  op = sexp_define_foreign(ctx, env, "change-directory", 1, sexp_change_directory_stub);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_OBJECT);
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(SEXP_STRING);
  }
  op = sexp_define_foreign(ctx, env, "current-directory", 0, sexp_current_directory_stub);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_STRING);
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(SEXP_CHAR);
    sexp_opcode_arg2_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
  }
  op = sexp_define_foreign(ctx, env, "rename-file", 2, sexp_rename_file_stub);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_OBJECT);
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(SEXP_STRING);
    sexp_opcode_arg2_type(op) = sexp_make_fixnum(SEXP_STRING);
  }
  op = sexp_define_foreign(ctx, env, "%delete-file", 1, sexp_25_delete_file_stub);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_OBJECT);
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(SEXP_STRING);
  }
  op = sexp_define_foreign(ctx, env, "fstat", 1, sexp_fstat_stub);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_OBJECT);
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
    sexp_opcode_arg2_type(op) = sexp_make_fixnum(sexp_type_tag(sexp_stat_type_obj));
  }
  op = sexp_define_foreign(ctx, env, "stat", 1, sexp_stat_stub);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_OBJECT);
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(SEXP_STRING);
    sexp_opcode_arg2_type(op) = sexp_make_fixnum(sexp_type_tag(sexp_stat_type_obj));
  }
  op = sexp_define_foreign(ctx, env, "S_ISSOCK", 1, sexp_S_ISSOCK_stub);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_BOOLEAN);
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
  }
  op = sexp_define_foreign(ctx, env, "S_ISLNK", 1, sexp_S_ISLNK_stub);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_BOOLEAN);
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
  }
  op = sexp_define_foreign(ctx, env, "S_ISFIFO", 1, sexp_S_ISFIFO_stub);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_BOOLEAN);
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
  }
  op = sexp_define_foreign(ctx, env, "S_ISBLK", 1, sexp_S_ISBLK_stub);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_BOOLEAN);
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
  }
  op = sexp_define_foreign(ctx, env, "S_ISCHR", 1, sexp_S_ISCHR_stub);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_BOOLEAN);
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
  }
  op = sexp_define_foreign(ctx, env, "S_ISDIR", 1, sexp_S_ISDIR_stub);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_BOOLEAN);
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
  }
  op = sexp_define_foreign(ctx, env, "S_ISREG", 1, sexp_S_ISREG_stub);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_BOOLEAN);
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
  }
  sexp_gc_release3(ctx);
  return SEXP_VOID;
}

